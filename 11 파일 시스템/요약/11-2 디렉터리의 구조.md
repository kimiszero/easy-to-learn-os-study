# 03. 디렉터리의 구조
* 이번 절에서는 디렉터리의 구성과 특징을 살펴봅니다. 

## 1. 디렉터리의 개념
* 디렉터리는 관련있는 파일을 하나로 모아놓은 곳이다. 한 개 이상의 자식 디렉터리를 가질 수 있고 1개 이상의 파일을 가질 수 있다. (너무 당연한 이야기네요)
* 디렉터리는 여러 층으로 구성할 수 있는데 가장 최상위에 있는 디렉터리를 루트 디렉터리라고 한다.  

<img width="284" alt="스크린샷 2022-11-13 오후 4 11 31" src="https://user-images.githubusercontent.com/77275707/201510327-0688939e-8668-40b3-81cc-2a50615bc8de.png">

> 유닉스에서는 슬래스(/)를 루트 디렉터리로 표시할 뿐만 아니라 디렉터리와 디렉터리 사이의 구분자로도 사용한다. 윈도우에서는 루트 디렉터리와 파티션의 이름을 같이 사용한다. 파티션의 이름은 알파벳과 콜론(:)으로 
> 구성되며 루트 디렉터리와 디렉터리 구분자로 백슬래시(\)를 사용한다. 

## 2. 디렉터리 파일
* 디렉터리도 파일이다. 일반 파일에는 데이터가 담겨 있고 디렉터리에는 파일 정보가 담겨있다. 디렉터리도 일반 파일과 마찬가지로 헤더를 가진다. 디렉터리 헤더에는 디렉터리의 이름, 만든 시간, 접근 권한 등의 정보가 기록되어 있다. 

<img width="454" alt="스크린샷 2022-11-13 오후 4 16 06" src="https://user-images.githubusercontent.com/77275707/201510520-6f01f90c-5a81-4424-ab59-54e0d61e539c.png">

* 위의 그림에서는 루트 디렉터리와 user디렉터리 파일을 나타낸 것이다. 그림에서 디렉터리 헤더는 디렉터리 정보가 시작되는 위치를 가리킨다. 
  * 즉 루트 디렉터리의 헤더는 5번 블록에, 디렉터리 내용은 7번 블록부터 저장되어 있고 
  * user 디렉터리의 헤더는 33번 블록에, 디렉터리의 내용은 35번부터 저장되어 있다. 

* 디렉터리에는 마침표(.) 파일과 2개의 마침표(..)파일이 있다. 마침표 파일은 자기 자신의 디렉터리를 가리키고, 2개 마침표 파일은 상위 디렉터리를 가리킨다. 
  * 루트 디렉터리의 마침표 파일은 자기 자신을 가리키므로 5번, 2개 마침표 파일은 상위 디렉터리를 가리켜야 하지만 루트 디렉터리가 최상위이기 때문에 자기 자신 즉 5번을 표시한다. 
  * user 디렉터리의 블록 번호 33번을 따라가면 user디렉터리의 헤더가 나온다. 헤더에는 디렉터리의 내용이 저장된 시작 블록 번호인 35가 저장되어 있다. 
    * 35번 블록에 가면 루트 디렉터리와 마찬가지로 마침표 파일은 자기 자신인 33번 블록을 가리키고 
    * 2개 마침표 파일은 상위 디렉터리인 루트 디렉터리 5번 블록을 가리킨다.    

## 3. 경로
* 경로는 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보이다. 한 디렉터리에는 같은 이름을 가진 파일이 존재할 수 없지만, 서로 다른 디렉터리에는 같은 이름의 파일이 존재할 수 있다. 
  * 절대경로: 루트 디렉터리를 기준으로 파일의 위치를 나타내는 방식 
    * 예시: /user/exm.c 
  * 상대경로: 현재 있는 위치를 기준으로 파일의 위치를 표시
    * 예시: ../user/exm.c

* 디렉터리를 이동할 때는 cd 명령을 사용한다. 절대 경로, 상대 경로를 모두 사용할 수 있는데 
  * 현재 위치보다 아래에 있는 데이터를 접근할 때는 상대 경로를 사용하고
  * 다른 디렉터리로 이동할 때는 절대 경로를 사용한다. 
<img width="381" alt="스크린샷 2022-11-13 오후 4 25 58" src="https://user-images.githubusercontent.com/77275707/201510794-e261a7f4-1dab-4689-9b06-4aacf6984fa3.png">

## 4. 디렉터리 구조

### 1단계 구조
* 초기 파일 시스템의 디렉터리는 1단계 구조였다. 당시에는 파일이 많지 않아서 많은 디렉터리가 필요하지 않았기 때문에 구조가 단순했다. 
* 1단계 디렉터리 구조에서는 루트 디렉터리에 새로운 디렉터리를 만들 수 있지만 디렉터리 안에 자식 디렉터리를 만들 수는 없었다. 최대 1단계만 구현 가능하고 디렉터리 안에는 파일만 존재함
<img width="341" alt="스크린샷 2022-11-13 오후 4 30 37" src="https://user-images.githubusercontent.com/77275707/201510972-8652b7ae-4436-46a0-9400-9a0a42f1c7b4.png">

### 다단계 구조
* 1단계 구조는 매우 단순하지만 파일이 많아지면 불편하여 다단계 디렉터리 구조가 등장한다.
* 다단계 디렉터리 구조는 루트 디렉터리를 시작점으로 여러 단계의 디렉터리가 가지처럼 뻗어 있어 나무를 뒤집어놓은 것 같아 트리 디렉터리 구조라고도 한다. 
* 단계 확장에 제약이 없고 디렉터리에 파일과 디렉터리 모두 저장할 수 있다. 
<img width="293" alt="스크린샷 2022-11-13 오후 4 31 54" src="https://user-images.githubusercontent.com/77275707/201511036-9554519a-6a26-4016-987b-a269cc3d7038.png">


* 자료구조에서는 트리를 순환이 없는 그래프라고 정의한다. 다단계 디렉터리는 순환이 없기 때문에 트리 구조이다. 
  * 그러나 오늘날의 디렉터리 구조에는 순환이 있다. 기본적으로는 트리 구조이지만 디렉터리와 디렉터리를 연결하는 링크가 있기 때문이다. 예를 들어 윈도우의 바로가기는 다른 디렉터리에 있는 파일이나 다른 
디렉터리로 갈 수 있는 지름길 역할을 한다. 바로가기 링크를 포함한 디렉터리 구조를 도식화하면 아래 그림과 같이 순환이 생긴다. 
  * 따라서 현재 그래프 구조는 `그래프 구조`이다. 
<img width="305" alt="스크린샷 2022-11-13 오후 4 36 48" src="https://user-images.githubusercontent.com/77275707/201511198-dea3baa2-1783-4c5a-bd0f-a2dcc2e3a628.png">

## 5. 마운트 
* 파티션은 논리적인 디스크 분할로, 하나 또는 여러 개의 디스크를 파티션으로 나누어 사용할 수 있다. 
  * 윈도우의 경우 C드라이브, D드라이브, E드라이브와 같이 문자를 붙여 각 파티션을 구분한다. 그런데 이렇게 파티션이 사용자에게 노출되면 사용하기 불편하다. 
  * 어떤 컴퓨터에 22개의 하드디스크가 있다고 하면 이 컴퓨터에는 C드라이브부터 Z 드라이브까지 있을 것이다. 여기에 새로 USB를 꽂으면 AA 드라이브가 된다. 
  * 윈도우에서 각 파티션이 따로 보이는 이유는 파티션마다 파일 테이블이 따로 존재하기 때문
<br>
* 윈도우에서 파티션을 나눌수밖에 없었던 이유는 초기 윈도우 개발 시의 파일 테이블 설계 문제에 있다. 
> 윈도우 FAT16 파일 시스템의 최대 디스크 크기는 32GB이다. 만약 100GB의 하드디스크를 FAT16파일 시스템으로 포맷하면 40GB, 40GB, 20GB의 세 파티션으로 나누어 써야 한다. 
> 이와 같이 초기 윈도우에서는 파일 시스템의 최대 디스크 크기가 제한되어 있기 때문에 아래 그림과 같이 파티션을 나누어 파티션마다 서로 다른 파일 테이블을 사용해야 했다. 
<img width="517" alt="스크린샷 2022-11-13 오후 4 42 18" src="https://user-images.githubusercontent.com/77275707/201511344-99cbdc74-8c08-4348-a0f9-ebef042195b4.png">

* 유닉스의 경우 서버용으로 만들어진 운영체제이므로 파일 테이블의 크기에 제한이 없다. 또한 하나의 파일 테이블로 여러 개의 디스크 혹은 파티션을 통합하여 관리할 수 있다. 
> 유닉스에서는 아래 그림과 같이 하나의 파일 테이블에 여러 개의 파티션을 붙여서 사용하는데 마운트는 이렇게 여러 개의 파티션을 통합하는 명령어이다. 
<img width="520" alt="스크린샷 2022-11-13 오후 4 43 56" src="https://user-images.githubusercontent.com/77275707/201511398-056f11de-a0a5-46f1-ad3a-c5f7a9b20f86.png">

* 아래 그림은 마운트를 이용하여 2개의 파티션을 하나의 파일 시스템으로 만든 예이다. 그림에서 보듯이 마운트를 이용하여 파티션2의 루트 디렉터리를 파티션1의 /mnt 디렉터리에 붙이면 2개의 파티션이 하나로 
합쳐진다. 마운트 된 후 a.mp4파일의 경로는 `/mnt/pref/a.mp4`가 된다. 이때 `/mnt`를 `연결 지점mounting point`라고 부른다. 마운트를 사용하면 디렉터리를 이동할 때마다 다른 파티션으로 넘어가지만 
사용자는 이를 알지 못한다. 사용자에게는 한 파티션으로 보이기 때문에 몇 개의 파티션이 합쳐져 있는지 모르는 것이다. 

<img width="520" alt="스크린샷 2022-11-13 오후 4 46 33" src="https://user-images.githubusercontent.com/77275707/201511508-c88cd055-7ef2-4748-8454-f464acabf722.png">

* 마운트를 사용하면 파티션이 몇 개라도 통합할 수 있다. 또한 CD-ROM이나 USB 메모리같은 외부 저장장치도 마운트로 파티션에 붙이고 마운트 해제로 분리할 수 있다. 
* 보통 유닉스 운영체제에서는 /dev 아래에 외부 저장장치를 마운트하여 사용한다. 
